# Practice problems

## Counting down from 4

    [ d      # save top stack value for posterity
    1-       # decrement top number
    d0<r]sr  # recurse if number is still greater than 0
    4lrx     # initialize and run macro
    f        # print resulting stack

    [d1-d0<r]sr4lrxf # single line version

## Factorial of 10

    [d1-d1<r*]sr10lrxp

## Fib series to one past 100

    [sbsalalblalb+d200>r]sr1 1lrxf

## Fib series to first number with 1000 digits

    [sbsalalblalb+dZ1000>r]sr1 1lrxf

# Euler Problem 1
> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

Pretty version

    1000 1-st             # Target number: just less than 1000
    [d1+*2/]ss            # find Sum 1..n
    [sa lt la/lsx la*]sm  # find sum of Multiples of n
    3lmx 5lmx + 15lmx - f

One line version

    1000 1-st[d1+*2/]ss[saltla/lsxla*]sm3lmx5lmx+15lmx-f

# Euler Problem 2
> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

Pretty version

    [ lblalb + lrx ]sf                 # iterate fib sequence
    [ lblt+st ]ss                      # add to total
    [ sbsa lb2%0=s lalb+4000000!<f ]sr # if even execute s, if < ceiling recurse
    1 1 0st lrx ltf                    # init and run

Short version

    [lblalb+lrx]sf[lblt+st]ss[sbsalb2%0=slalb+4000000!<f]sr1 1 0stlrxltf

# Euler Problem 3
> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143 ?
>
> (Answer: 6857)

Pretty version

    Variables:
    t: target number
    i: index, test against target
    m: current max prime

    [  # main
      li1+si    # i++
      ltli%0=R  # if divisible, reduce target
      lilt>M    # if target > i, recurse
    ]sM

    [  # reduce target
      lilm<P   # if i is greater than max, set as new max
      ltli/st  # set new t
      1si      # reset index
    ]sR

    [  # set new max prime
      lism
    ]sP

    600851475143st  # Initalize t
    1sm             # Initalize m
    1si             # Initalize i

    lMx  # run main
    lmp  # print max

Short version

    [lilm<Pltli/st1si]sR[lism]sP[li1+siltli%0=Rlilt>M]sM600851475143st1sm1silMxlmp
